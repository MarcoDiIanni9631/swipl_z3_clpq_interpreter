% Automatically generated by smt2map




:- pred 'main@entry'(int).
:- mode 'main@entry'(in).
:- pred 'main@id.exit.split'.
:- pred 'main@tailrecurse.i'(int,int).
:- mode 'main@tailrecurse.i'(in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A) :- constr((true)).
'main@tailrecurse.i'(A,B) :- 'main@entry'(C), 
          constr((D=(E=0)&(F=true&(and(G,H)&(not(G)&(and(G,F)&(not(F)&(B=I&(not(F)&(not(G)&(A=J&(not(F)&(not(G)&(I=0&(not(F)&(not(G)&(J=E&(not(F)&(not(G)&(not(H)&(not(D)&(not(G)&K=C)))))))))))))))))))))).
'main@tailrecurse.i'(A,B) :- 'main@tailrecurse.i'(C,D), 
          constr((E=(F=0)&(G=true&(and(H,G)&(not(G)&(not(E)&(not(G)&(not(H)&(B=I&(not(G)&(not(H)&(A=J&(not(G)&(not(H)&(I=K&(not(G)&(not(H)&(J=F&(not(G)&(not(H)&(K=1+D&F= - 1+C))))))))))))))))))))).
'main@id.exit.split' :- 'main@entry'(A), 
          constr((B=(C=0)&(D=true&(and(D,E)&(not(D)&(F&(not(E)&(and(E,G)&(not(E)&(not(G)&(not(H)&(not(E)&(B&(not(G)&(not(E)&(F=H&(not(G)&(not(E)&I=A)))))))))))))))))).
'main@id.exit.split' :- 'main@tailrecurse.i'(A,B), 
          constr((C=(D=0)&(E=true&(and(E,F)&(not(E)&(G&(not(F)&(and(F,H)&(not(F)&(and(H,I)&(not(H)&(J=(K=100)&(not(H)&(L=J&(not(H)&(not(F)&(G=L&(not(H)&(not(F)&(C&(not(I)&(not(H)&(K=M&(not(I)&(not(H)&(M=N&(not(I)&(not(H)&(N=1+B&D= - 1+A))))))))))))))))))))))))))))).
ff :- 'main@id.exit.split', constr((true)).

