% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@tailrecurse.i'(int,int,int,int).
:- mode 'main@tailrecurse.i'(in,in,in,in).
:- pred 'main@sum.exit.split'.
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B,C,D) :- 'main@entry', 
          constr((E=(B=0)&(F=true&(and(G,H)&(not(G)&(and(G,F)&(not(F)&(D=I&(not(F)&(not(G)&(C=J&(not(F)&(not(G)&(J=B&(not(F)&(not(G)&(I=A&(not(F)&(not(G)&(not(H)&(not(E)&not(G)))))))))))))))))))))).
'main@tailrecurse.i'(A,B,C,D) :- 'main@tailrecurse.i'(A,B,E,F), 
          constr((G=(H=0)&(I=true&(and(J,I)&(not(I)&(not(G)&(not(I)&(not(J)&(D=K&(not(I)&(not(J)&(C=L&(not(I)&(not(J)&(L=H&(not(I)&(not(J)&(K=M&(not(I)&(not(J)&(H= - 1+E&M=1+F))))))))))))))))))))).
'main@sum.exit.split' :- 'main@entry', 
          constr((A=(B=0)&(C=true&(and(C,D)&(not(C)&(E&(not(D)&(and(F,D)&(not(D)&(G=H+B&(not(D)&(E=(I=G)&(not(D)&(not(D)&(A&(not(F)&(not(D)&(I=J&(not(F)&(not(D)&(J=H&not(F)))))))))))))))))))))).
'main@sum.exit.split' :- 'main@tailrecurse.i'(A,B,C,D), 
          constr((E=(F=0)&(G=true&(and(H,I)&(not(H)&(and(G,J)&(not(G)&(K&(not(J)&(and(H,J)&(not(J)&(L=A+B&(not(J)&(K=(M=L)&(not(J)&(not(J)&(M=N&(not(H)&(not(J)&(N=O&(not(H)&(E&(not(I)&(not(H)&(O=P&(not(I)&(not(H)&(P=Q&(not(I)&(not(H)&(Q=1+D&F= - 1+C))))))))))))))))))))))))))))))).
ff :- 'main@sum.exit.split', constr((true)).

