% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@tailrecurse.i3'(bool,int,int).
:- mode 'main@tailrecurse.i3'(in,in,in).
:- pred 'main@a.exit4.split'.
:- pred 'main@tailrecurse.i'(bool,int,int,int,int).
:- mode 'main@tailrecurse.i'(in,in,in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B,C,D,E) :- 'main@entry', 
          constr((A=(B=0)&(F=true&(and(G,F)&(not(F)&(E=H&(not(F)&(not(G)&(D=I&(not(F)&(not(G)&(H=C&(not(F)&(not(G)&(I=B&(not(F)&(not(G)&C=ite(A,1,0)))))))))))))))))).
'main@tailrecurse.i'(A,B,C,D,E) :- 'main@tailrecurse.i'(A,B,C,F,G), 
          constr((H=(F=0)&(I=true&(and(J,I)&(not(I)&(not(H)&(not(I)&(not(J)&(E=K&(not(I)&(not(J)&(D=L&(not(I)&(not(J)&(K=F&(not(I)&(not(J)&(L=G&(not(I)&not(J)))))))))))))))))))).
'main@tailrecurse.i3'(A,B,C) :- 'main@tailrecurse.i'(A,D,E,F,G), 
          constr((H=(F=0)&(I=true&(and(J,K)&(not(J)&(and(J,I)&(not(I)&(C=L&(not(I)&(not(J)&(B=M&(not(I)&(not(J)&(L=E&(not(I)&(not(J)&(M=D&(not(I)&(not(J)&(not(K)&(not(J)&H))))))))))))))))))))).
'main@tailrecurse.i3'(A,B,C) :- 'main@tailrecurse.i3'(A,D,E), 
          constr((F=(D=0)&(G=true&(and(H,G)&(not(G)&(not(F)&(not(G)&(not(H)&(C=I&(not(G)&(not(H)&(B=J&(not(G)&(not(H)&(I=D&(not(G)&(not(H)&(J=E&(not(G)&not(H)))))))))))))))))))).
'main@a.exit4.split' :- 'main@tailrecurse.i3'(A,B,C), 
          constr((D=(B=0)&(E=true&(and(E,F)&(not(E)&(not(A)&(not(F)&(and(F,G)&(not(F)&(D&(not(G)&not(F)))))))))))).
ff :- 'main@a.exit4.split', constr((true)).

