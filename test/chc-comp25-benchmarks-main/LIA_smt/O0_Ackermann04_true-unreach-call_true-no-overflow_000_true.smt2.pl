% Automatically generated by smt2map




:- pred 'main@verifier.error.split'.
:- pred 'ackermann@.split'(int,int,int).
:- mode 'ackermann@.split'(in,in,in).
:- pred 'main@entry'.
:- pred ackermann(bool,bool,bool,int,int,int).
:- mode ackermann(in,in,in,in,in,in).
:- pred 'ackermann@_call'(int,int).
:- mode 'ackermann@_call'(in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

ackermann(A,B,C,D,E,F) :- constr((and(true,and(A=true,and(B=true,C=true))))).
ackermann(A,B,C,D,E,F) :- constr((and(true,and(A=false,and(B=true,C=true))))).
ackermann(A,B,C,D,E,F) :- constr((and(true,and(A=false,and(B=false,C=false))))).
ackermann(A,B,C,D,E,F) :- constr((and(A=true,and(B=false,C=false)))), 
          'ackermann@.split'(F,E,D).
'ackermann@_call'(A,B) :- constr((true)).
'ackermann@.split'(A,B,C) :- 
          constr((and(D=false,and(E=false,and(F=false,and(G=false,and(H=false,and(I=false,and(1=J,and(or(not(K),and(K,L),and(K,M),and(K,N)),and(or(not(O),not(P),not(Q)),and(or(not(N),not(R),not(Q)),and(or(not(M),not(Q),R),and(or(not(L),O,not(P)),and(or(not(K),not(N),S=T),and(or(not(K),not(N),A=S),and(or(not(K),not(M),U=V),and(or(not(K),not(M),A=U),and(or(not(K),not(L),W=X),and(or(not(K),not(L),A=W),and(or(not(Q),R=(B=0)),and(or(not(Q),Y= - 1+C),and(or(not(Q),and(P,Q)),and(or(not(N),Z= - 1+B),and(or(not(N),and(N,Q)),and(or(not(M),and(M,Q)),and(or(not(L),X=1+B),and(or(not(L),and(L,P)),and(or(not(A1),and(A1,K)),and(A1=true,O=(C=0))))))))))))))))))))))))))))))), 
          'ackermann@_call'(B,C), ackermann(N,D,E,C,Z,B1), 
          ackermann(N,F,G,Y,B1,T), ackermann(M,H,I,Y,J,V).
'main@entry' :- constr((true)).
'main@verifier.error.split' :- 
          constr((and(and(A=false,B=false,or(not(C),D),or(not(C),and(E,C)),or(not(C),not(F)),or(not(G),and(H,G)),I,J,K,or(not(H),L=or(M,N)),or(not(H),O=or(L,P)),or(not(H),and(H,C)),or(not(H),not(O)),or(not(Q),and(Q,G)),or(not(R),and(R,Q)),not(S),R=true,T),and(D=(F=or(not(U=<23),not(U>=0))),and(I=or(not(H),not((2=<U)=M)),and(J=or(not(H),not((2=<V)=N)),and(K=or(not(H),not((W=<6)=P)),T=(S=or(not(V=<3),not(V>=0)))))))))), 
          'main@entry', ackermann(H,A,B,V,U,W).
ff :- constr((true)), 'main@verifier.error.split'.

