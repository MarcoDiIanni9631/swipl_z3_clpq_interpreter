% Automatically generated by smt2map




:- pred 'ackermann@_tail'(int,int).
:- mode 'ackermann@_tail'(in,in).
:- pred 'main@entry'.
:- pred 'main@entry.split'.
:- pred 'ackermann@.lr.ph'(int,int,int,int).
:- mode 'ackermann@.lr.ph'(in,in,in,in).
:- pred ackermann(bool,bool,bool,int,int,int).
:- mode ackermann(in,in,in,in,in,in).
:- pred 'ackermann@tailrecurse._crit_edge.split'(int,int,int).
:- mode 'ackermann@tailrecurse._crit_edge.split'(in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

ackermann(A,B,C,D,E,F) :- constr((and(true,and(A=true,and(B=true,C=true))))).
ackermann(A,B,C,D,E,F) :- constr((and(true,and(A=false,and(B=true,C=true))))).
ackermann(A,B,C,D,E,F) :- constr((and(true,and(A=false,and(B=false,C=false))))).
ackermann(A,B,C,D,E,F) :- constr((and(A=true,and(B=false,C=false)))), 
          'ackermann@tailrecurse._crit_edge.split'(F,E,D).
'ackermann@_tail'(A,B) :- constr((true)).
'ackermann@.lr.ph'(A,B,C,D) :- 
          constr((and(or(not(E),not(F),not(G)),and(or(not(E),not(H),I=C),and(or(not(E),not(H),J=D),and(or(not(E),not(H),A=I),and(or(not(E),not(H),B=J),and(or(not(H),and(E,H)),and(or(not(E),and(E,G)),and(H=true,F=(D=0))))))))))), 
          'ackermann@_tail'(C,D).
'ackermann@.lr.ph'(A,B,C,D) :- 
          constr((and(E=false,and(F=false,and(G= - 1+H,and(or(not(I),not(J),not(K)),and(or(not(L),not(I),M=1),and(or(not(L),not(I),N=M),and(or(not(L),not(I),K),and(or(not(O),and(O,J),and(L,I)),and(or(not(O),not(J),P=Q),and(or(not(O),not(J),N=P),and(or(not(O),not(R),S=N),and(or(not(O),not(R),T=G),and(or(not(O),not(R),A=S),and(or(not(O),not(R),B=T),and(or(not(O),not(R),not(U)),and(or(not(J),V= - 1+W),and(or(not(J),and(I,J)),and(or(not(L),I),and(or(not(R),and(O,R)),and(or(not(O),U=(G=0)),and(R=true,K=(W=0)))))))))))))))))))))))), 
          'ackermann@.lr.ph'(W,H,C,D), ackermann(J,E,F,H,V,Q).
'ackermann@tailrecurse._crit_edge.split'(A,B,C) :- 
          constr((and(or(not(D),not(E),F=B),and(or(not(D),not(E),G=F),and(or(H,not(D),not(E)),and(or(not(D),A=1+G),and(or(not(D),and(D,E)),and(or(not(I),and(I,D)),and(I=true,H=(C=0)))))))))), 
          'ackermann@_tail'(B,C).
'ackermann@tailrecurse._crit_edge.split'(A,B,C) :- 
          constr((and(D=false,and(E=false,and(F= - 1+G,and(or(not(H),not(I),not(J)),and(or(not(K),not(H),L=1),and(or(not(K),not(H),M=L),and(or(not(K),not(H),J),and(or(not(N),and(N,I),and(K,H)),and(or(not(N),not(I),O=P),and(or(not(N),not(I),M=O),and(or(not(Q),not(N),R=M),and(or(not(Q),not(N),S=R),and(or(not(Q),not(N),T),and(or(not(U),not(Q),V=S),and(or(not(U),not(Q),W=V),and(or(not(I),X= - 1+Y),and(or(not(I),and(H,I)),and(or(not(K),H),and(or(not(N),T=(F=0)),and(or(not(Q),and(Q,N)),and(or(not(U),A=1+W),and(or(not(U),and(U,Q)),and(or(not(Z),and(Z,U)),and(Z=true,J=(Y=0))))))))))))))))))))))))))), 
          'ackermann@.lr.ph'(Y,G,B,C), ackermann(I,D,E,G,X,P).
'main@entry' :- constr((true)).
'main@entry.split' :- 
          constr((and(and(A=true,B=false,C=false,not((D=2)=E),F,G,H=or(I,J),J=or(E,K),I=(L=7),or(not(M),and(M,N)),not(O),not(P),not(H),M=true,not((Q=2)=K)),and(F=(O=or(not(Q=<3),not(Q>=0))),G=(P=or(not(D=<23),not(D>=0))))))), 
          'main@entry', ackermann(A,B,C,Q,D,L).
ff :- constr((true)), 'main@entry.split'.

