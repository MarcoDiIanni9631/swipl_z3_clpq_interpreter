% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@iseven.exit.split'.
:- pred 'main@tailrecurse.i'(int,int).
:- mode 'main@tailrecurse.i'(in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B) :- 'main@entry', 
          constr((and(or(not(C),not(D),B=E),and(or(not(D),and(C,D)),and(D=true,or(not(C),not(D),E=A)))))).
'main@tailrecurse.i'(A,B) :- 'main@tailrecurse.i'(A,C), 
          constr((and(or(not(D),E,not(F)),and(or(not(G),not(H),not(D)),and(or(not(I),not(E),not(F)),and(or(not(J),not(K),not(I)),and(or(not(L),and(K,I),and(H,D)),and(or(not(L),not(M),N=O),and(or(not(L),not(M),B=N),and(or(not(L),not(M),not(P)),and(or(not(D),G=(C=0)),and(or(not(D),and(D,F)),and(or(not(H),D),and(or(not(I),J=(C=1)),and(or(not(I),and(I,F)),and(or(not(K),I),and(or(not(M),and(L,M)),and(or(not(L),P=(C=2)),and(or(not(L),O= - 2+C),and(M=true,not((1=<C)=E))))))))))))))))))))).
'main@iseven.exit.split' :- 'main@tailrecurse.i'(A,B), 
          constr((and(or(not(C),and(D,E),and(F,G),and(H,I)),and(or(not(I),and(D,J),and(G,K)),and(or(not(H),not(I),L=1),and(or(not(H),not(I),M=L),and(or(not(H),not(I),N),and(or(not(G),O,not(P)),and(or(not(G),not(Q),not(K)),and(or(not(F),not(G),R=1),and(or(not(F),not(G),M=R),and(or(not(F),not(G),Q),and(or(not(D),not(O),not(P)),and(or(not(D),not(E),S=0),and(or(not(D),not(E),M=S),and(or(not(D),not(T),not(J)),and(or(not(D),T,not(E)),and(or(not(C),U=(M=V)),and(or(not(C),V=A mod 2),and(or(not(C),not(U)),and(or(not(W),and(W,C)),and(or(not(I),N=(B=2)),and(or(not(I),X= - 2+B),and(or(not(H),I),and(or(not(G),Q=(B=0)),and(or(not(G),and(G,P)),and(or(G,not(K)),and(or(not(F),G),and(or(not(D),T=(B=1)),and(or(not(D),and(D,P)),and(or(D,not(J)),and(or(D,not(E)),and(W=true,not((1=<B)=O)))))))))))))))))))))))))))))))))).
ff :- 'main@iseven.exit.split', constr((true)).

