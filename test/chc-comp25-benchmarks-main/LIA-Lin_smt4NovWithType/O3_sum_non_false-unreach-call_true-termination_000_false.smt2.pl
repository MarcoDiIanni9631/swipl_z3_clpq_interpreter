% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@tailrecurse.i'(int,int,int,int).
:- mode 'main@tailrecurse.i'(in,in,in,in).
:- pred 'main@sum.exit.split'.
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B,C,D) :- 'main@entry', 
          constr((and(or(not(E),not(F),not(G)),and(or(not(E),not(H),I=A),and(or(not(E),not(H),J=B),and(or(not(E),not(H),C=J),and(or(not(E),not(H),D=I),and(or(not(H),and(E,H)),and(or(not(E),and(E,G)),and(H=true,not((1=<B)=F))))))))))).
'main@tailrecurse.i'(A,B,C,D) :- 'main@tailrecurse.i'(A,B,E,F), 
          constr((and(G= - 1+E,and(not((2=<E)=H),and(or(not(I),not(J),K=L),and(or(not(I),not(J),M=G),and(or(not(I),not(J),C=M),and(or(not(I),not(J),D=K),and(or(not(I),not(J),not(H)),and(or(not(J),and(I,J)),and(J=true,L=1+F))))))))))).
'main@sum.exit.split' :- 'main@entry', 
          constr((and(or(not(A),not(B),C=D),and(or(not(A),not(B),E=F),and(or(not(A),not(B),G=E),and(or(not(A),not(B),H=C),and(or(not(A),not(B),I),and(or(not(A),J=G+H),and(or(not(A),K=D+F),and(or(not(A),L=(J=K)),and(or(not(A),and(A,B)),and(or(not(A),L),and(or(not(M),and(M,A)),and(M=true,not((1=<F)=I))))))))))))))).
'main@sum.exit.split' :- 'main@tailrecurse.i'(A,B,C,D), 
          constr((and(E= - 1+C,and(not((2=<C)=F),and(or(not(G),not(H),I=J),and(or(not(G),not(H),K=E),and(or(not(G),not(H),L=I),and(or(not(G),not(H),M=K),and(or(not(G),not(H),F),and(or(not(N),not(G),O=L),and(or(not(N),not(G),P=M),and(or(not(N),not(G),Q=P),and(or(not(N),not(G),R=O),and(or(not(G),and(G,H)),and(or(not(N),S=Q+R),and(or(not(N),T=A+B),and(or(not(N),U=(S=T)),and(or(not(N),and(N,G)),and(or(not(N),U),and(or(not(V),and(V,N)),and(V=true,J=1+D))))))))))))))))))))).
ff :- 'main@sum.exit.split', constr((true)).

