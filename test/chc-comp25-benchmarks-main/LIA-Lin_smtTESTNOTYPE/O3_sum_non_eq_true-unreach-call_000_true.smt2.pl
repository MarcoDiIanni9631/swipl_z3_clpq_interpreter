% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@tailrecurse.i'(int,int,int,int).
:- mode 'main@tailrecurse.i'(in,in,in,in).
:- pred 'main@sum.exit.split'.
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B,C,D) :- 'main@entry', 
          constr((and(or(not(E),not(F),not(G)),and(or(not(E),not(H),I=A),and(or(not(E),not(H),J=B),and(or(not(E),not(H),C=J),and(or(not(E),not(H),D=I),and(or(not(H),and(E,H)),and(or(not(E),and(E,G)),and(H=true,F=(B=0))))))))))).
'main@tailrecurse.i'(A,B,C,D) :- 'main@tailrecurse.i'(A,B,E,F), 
          constr((and(G=1+F,and(H= - 1+E,and(or(not(I),not(J),K=G),and(or(not(I),not(J),L=H),and(or(not(I),not(J),C=L),and(or(not(I),not(J),D=K),and(or(not(I),not(J),not(M)),and(or(not(J),and(I,J)),and(J=true,M=(H=0)))))))))))).
'main@sum.exit.split' :- 'main@entry', 
          constr((and(or(not(A),B=C,not(D)),and(or(not(A),E=B,not(D)),and(or(not(A),F,not(D)),and(or(not(D),G=(E=H)),and(or(not(D),H=C+I),and(or(not(D),and(A,D)),and(or(not(D),not(G)),and(or(not(J),and(J,D)),and(J=true,F=(I=0)))))))))))).
'main@sum.exit.split' :- 'main@tailrecurse.i'(A,B,C,D), 
          constr((and(E= - 1+C,and(F=1+D,and(or(not(G),not(H),I=F),and(or(not(G),not(H),J=I),and(or(not(G),not(H),K),and(or(not(G),L=J,not(M)),and(or(not(G),N=L,not(M)),and(or(not(M),O=(N=P)),and(or(not(M),P=A+B),and(or(not(M),and(G,M)),and(or(not(M),not(O)),and(or(not(Q),and(Q,M)),and(or(not(G),and(G,H)),and(Q=true,K=(E=0))))))))))))))))).
ff :- 'main@sum.exit.split', constr((true)).

