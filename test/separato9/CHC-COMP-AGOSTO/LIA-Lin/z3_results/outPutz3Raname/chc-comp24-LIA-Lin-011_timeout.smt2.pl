% Automatically generated by smt2map




:- pred 'main@entry'(int).
:- mode 'main@entry'(in).
:- pred 'main@orig.main.exit.split'.
:- pred 'main@.lr.ph'(int,int,int).
:- mode 'main@.lr.ph'(in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A) :- constr((true)).
'main@.lr.ph'(A,B,C) :- 'main@entry'(D), 
          constr((E=(A=0)&(F=true&(and(G,H)&(not(G)&(and(G,F)&(not(F)&(C=I&(not(F)&(not(G)&(B=J&(not(F)&(not(G)&(J=A&(not(F)&(not(G)&(I=0&(not(F)&(not(G)&(not(H)&(not(E)&(not(G)&K=D)))))))))))))))))))))).
'main@.lr.ph'(A,B,C) :- 'main@.lr.ph'(A,D,E), 
          constr((F=(G=0)&(H=true&(and(I,H)&(not(H)&(not(F)&(not(H)&(not(I)&(C=J&(not(H)&(not(I)&(B=K&(not(H)&(not(I)&(K=G&(not(H)&(not(I)&(J=L&(not(H)&(not(I)&(G= - 1+D&L=1+E))))))))))))))))))))).
'main@orig.main.exit.split' :- 'main@entry'(A), 
          constr((B=(C=0)&(D=true&(not(E)&(not(F)&(and(D,F)&(not(D)&(G&(not(F)&(and(H,F)&(not(F)&(not(I=G)&(not(F)&(I=(J=C)&(not(F)&(B&(not(F)&(not(H)&(J=K&(not(F)&(not(H)&(K=0&(not(F)&(not(H)&L=A)))))))))))))))))))))))).
'main@orig.main.exit.split' :- 'main@.lr.ph'(A,B,C), 
          constr((D=(E=0)&(F=true&(not(G)&(not(H)&(and(I,J)&(not(I)&(and(F,H)&(not(F)&(K&(not(H)&(and(I,H)&(not(H)&(not(L=K)&(not(H)&(L=(M=A)&(not(H)&(M=N&(not(H)&(not(I)&(N=O&(not(H)&(not(I)&(D&(not(J)&(not(I)&(O=P&(not(J)&(not(I)&(P=Q&(not(J)&(not(I)&(Q=1+C&E= - 1+B))))))))))))))))))))))))))))))))).
ff :- 'main@orig.main.exit.split', constr((true)).

