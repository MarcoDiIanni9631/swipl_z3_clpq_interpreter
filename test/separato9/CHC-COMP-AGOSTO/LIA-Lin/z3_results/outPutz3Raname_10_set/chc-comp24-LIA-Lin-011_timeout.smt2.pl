% Automatically generated by smt2map




:- pred 'main@entry'(int).
:- mode 'main@entry'(in).
:- pred 'main@orig.main.exit.split'.
:- pred 'main@.lr.ph'(int,int,int).
:- mode 'main@.lr.ph'(in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A) :- constr((true)).
'main@.lr.ph'(A,B,C) :- 'main@entry'(D), 
          constr((E=(A=0)&(F=true&(or(not(G),and(G,H))&(or(not(F),and(G,F))&(or(not(G),or(not(F),C=I))&(or(not(G),or(not(F),B=J))&(or(not(G),or(not(F),J=A))&(or(not(G),or(not(F),I=0))&(or(not(G),or(not(E),not(H)))&K=D)))))))))).
'main@.lr.ph'(A,B,C) :- 'main@.lr.ph'(A,D,E), 
          constr((F=(G=0)&(H=true&(or(not(H),and(I,H))&(or(not(I),or(not(H),not(F)))&(or(not(I),or(not(H),C=J))&(or(not(I),or(not(H),B=K))&(or(not(I),or(not(H),K=G))&(or(not(I),or(not(H),J=L))&(G= - 1+D&L=1+E)))))))))).
'main@orig.main.exit.split' :- 'main@entry'(A), 
          constr((B=(C=0)&(D=true&(or(not(E),not(F))&(or(not(D),and(D,E))&(or(not(E),G)&(or(not(E),and(H,E))&(or(not(E),not(I=G))&(or(not(E),I=(J=C))&(or(not(H),or(not(E),B))&(or(not(H),or(not(E),J=K))&(or(not(H),or(not(E),K=0))&L=A)))))))))))).
'main@orig.main.exit.split' :- 'main@.lr.ph'(A,B,C), 
          constr((D=(E=0)&(F=true&(or(not(G),not(H))&(or(not(I),and(I,J))&(or(not(F),and(F,G))&(or(not(G),K)&(or(not(G),and(I,G))&(or(not(G),not(L=K))&(or(not(G),L=(M=A))&(or(not(I),or(not(G),M=N))&(or(not(I),or(not(G),N=O))&(or(not(I),or(not(J),D))&(or(not(I),or(not(J),O=P))&(or(not(I),or(not(J),P=Q))&(Q=1+C&E= - 1+B)))))))))))))))).
ff :- 'main@orig.main.exit.split', constr((true)).

