% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@isodd.exit.split'.
:- pred 'main@tailrecurse.i'(int,int).
:- mode 'main@tailrecurse.i'(in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B) :- 'main@entry', 
          constr((~ ((0=<A)=C)&(D=true&(~C&(or(not(D),and(E,D))&(or(not(E),or(not(D),B=F))&or(not(E),or(not(D),F=A)))))))).
'main@tailrecurse.i'(A,B) :- 'main@tailrecurse.i'(A,C), 
          constr((~ ((1=<C)=D)&(E=true&(or(not(F),G=(C=2))&(or(not(F),H= - 2+C)&(or(not(E),and(F,E))&(or(not(I),J)&(or(not(J),and(J,K))&(or(not(J),L=(C=1))&(or(not(M),N)&(or(not(N),and(N,K))&(or(not(N),O=(C=0))&(or(not(F),or(not(E),not(G)))&(or(not(F),or(not(E),B=P))&(or(not(F),or(not(E),P=H))&(or(not(F),or(and(I,J),and(M,N)))&(or(not(L),or(not(I),not(J)))&(or(not(J),or(not(D),not(K)))&(or(not(O),or(not(M),not(N)))&or(not(N),or(D,not(K)))))))))))))))))))))).
'main@isodd.exit.split' :- 'main@tailrecurse.i'(A,B), 
          constr((~ ((1=<B)=C)&(D=true&(or(E,not(F))&(or(E,not(G))&(or(not(E),and(E,H))&(or(not(E),I=(B=1))&(or(not(J),K)&(or(K,not(L))&(or(not(K),and(K,H))&(or(not(K),M=(B=0))&(or(not(N),O)&(or(not(O),P=(B=2))&(or(not(O),Q= - 2+B)&(or(not(D),and(D,R))&(or(not(R),not(S))&(or(not(R),S=(T=U))&(or(not(R),U=A mod 2)&(or(not(E),or(I,not(F)))&(or(not(E),or(not(I),not(G)))&(or(not(E),or(not(F),T=V))&(or(not(E),or(not(F),V=1))&(or(not(E),or(not(C),not(H)))&(or(not(J),or(not(K),M))&(or(not(J),or(not(K),T=W))&(or(not(J),or(not(K),W=0))&(or(not(K),or(not(M),not(L)))&(or(not(K),or(C,not(H)))&(or(not(N),or(not(O),P))&(or(not(N),or(not(O),T=X))&(or(not(N),or(not(O),X=0))&(or(not(O),or(and(E,G),and(K,L)))&or(not(R),or(and(E,F),or(and(J,K),and(N,O)))))))))))))))))))))))))))))))))))).
ff :- 'main@isodd.exit.split', constr((true)).

