% Automatically generated by smt2map




:- pred 'main@entry'(int).
:- mode 'main@entry'(in).
:- pred 'main@orig.main.exit.split'.
:- pred 'main@.lr.ph'(int,int,int).
:- mode 'main@.lr.ph'(in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A) :- constr((true)).
'main@.lr.ph'(A,B,C) :- 'main@entry'(D), 
          constr((~ ((1=<A)=E)&(F=true&(or(not(G),and(G,H))&(or(not(F),and(G,F))&(or(not(G),or(not(F),C=I))&(or(not(G),or(not(F),B=J))&(or(not(G),or(not(F),I=1))&(or(not(G),or(not(F),J=0))&(or(not(G),or(not(E),not(H)))&K=D)))))))))).
'main@.lr.ph'(A,B,C) :- 'main@.lr.ph'(A,D,E), 
          constr((~ ((A=<E)=F)&(G=true&(or(not(G),and(H,G))&(or(not(H),or(not(G),F))&(or(not(H),or(not(G),C=I))&(or(not(H),or(not(G),B=J))&(or(not(H),or(not(G),I=K))&(or(not(H),or(not(G),J=L))&(K=1+E&(L=ite(M,- 10,N)&(N=2+D&M=(E=4))))))))))))).
'main@orig.main.exit.split' :- 'main@entry'(A), 
          constr((~ ((1=<B)=C)&(D=true&(or(not(E),not(F))&(or(not(D),and(D,F))&(or(not(F),G)&(or(not(F),and(F,H))&(or(not(F),I=2*B)&(or(not(F),J=(K=0))&(or(not(F),not(L=G))&(or(not(F),L=or(J,M))&(or(not(F),M=(K=I))&(or(not(F),or(not(H),C))&(or(not(F),or(not(H),N=0))&(or(not(F),or(not(H),K=N))&O=A))))))))))))))).
'main@orig.main.exit.split' :- 'main@.lr.ph'(A,B,C), 
          constr((~ ((A=<C)=D)&(E=true&(or(not(F),not(G))&(or(not(E),and(E,G))&(or(not(G),H)&(or(not(G),and(G,I))&(or(not(G),J=2*A)&(or(not(G),K=(L=0))&(or(not(G),not(M=H))&(or(not(G),M=or(K,N))&(or(not(G),N=(L=J))&(or(not(I),and(I,O))&(or(not(G),or(not(I),P=Q))&(or(not(G),or(not(I),L=P))&(or(not(I),or(not(O),not(D)))&(or(not(I),or(not(O),R=S))&(or(not(I),or(not(O),Q=R))&(S=ite(T,- 10,U)&(V=1+C&(U=2+B&T=(C=4)))))))))))))))))))))).
ff :- 'main@orig.main.exit.split', constr((true)).

