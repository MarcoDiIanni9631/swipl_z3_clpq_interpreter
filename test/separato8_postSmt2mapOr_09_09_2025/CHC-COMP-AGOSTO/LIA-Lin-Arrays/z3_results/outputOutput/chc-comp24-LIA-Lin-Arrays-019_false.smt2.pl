% Automatically generated by smt2map




:- pred 'main@entry'(int,array(int),int).
:- mode 'main@entry'(in,in,in).
:- pred 'main@orig.main.exit.split'.
:- pred 'main@.lr.ph'(int,array(int),int).
:- mode 'main@.lr.ph'(in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A,B,C) :- constr((true)).
'main@.lr.ph'(A,B,C) :- 'main@entry'(A,D,E), 
          constr((~ ((F=<0)=G)&(H=true&(or(not(I),and(I,J))&(or(not(H),and(I,H))&(or(not(I),or(not(H),B=K))&(or(not(I),or(not(H),K=L))&(or(not(J),or(G,not(I)))&(L=store(M,C,F)&(M=store(D,C,0)&N=E)))))))))).
'main@.lr.ph'(A,B,C) :- 'main@.lr.ph'(A,D,C), 
          constr((~ ((E=<1)=F)&(G=true&(or(not(G),and(H,G))&(or(not(H),or(not(G),F))&(or(not(H),or(not(G),B=I))&(or(not(H),or(not(G),I=J))&(J=store(D,C,K)&(K= - 1+E&(L=A&E=select(D,C))))))))))).
'main@orig.main.exit.split' :- 'main@entry'(A,B,C), 
          constr((~ ((D=<0)=E)&(F=true&(or(not(G),not(H))&(or(not(F),and(F,G))&(or(not(G),I)&(or(not(G),and(J,G))&(or(not(G),not(K=I))&(or(not(G),K=(L=0))&(or(not(G),or(not(E),not(J)))&(or(not(G),or(M=N,not(J)))&(or(not(G),or(O=M,not(J)))&(or(not(G),or(L=P,not(J)))&(or(not(G),or(P=D,not(J)))&(N=store(Q,R,D)&(Q=store(B,R,0)&S=C)))))))))))))))).
'main@orig.main.exit.split' :- 'main@.lr.ph'(A,B,C), 
          constr((~ ((D=<1)=E)&(F=true&(or(not(G),not(H))&(or(not(I),and(I,J))&(or(not(F),and(F,G))&(or(not(G),K)&(or(not(G),and(I,G))&(or(not(G),not(L=K))&(or(not(G),L=(M=0))&(or(not(G),or(N=O,not(I)))&(or(not(G),or(P=N,not(I)))&(or(not(G),or(M=Q,not(I)))&(or(not(G),or(Q=R,not(I)))&(or(not(I),or(not(J),not(E)))&(or(not(I),or(not(J),S=T))&(or(not(I),or(not(J),R=S))&(O=store(B,C,T)&(D=select(B,C)&(T= - 1+D&U=A)))))))))))))))))))).
ff :- 'main@orig.main.exit.split', constr((true)).

