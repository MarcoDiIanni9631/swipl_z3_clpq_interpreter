% Automatically generated by smt2map




:- pred 'main@entry'(int).
:- mode 'main@entry'(in).
:- pred 'main@orig.main.exit.split'.
:- pred 'main@.lr.ph'(int,int,int).
:- mode 'main@.lr.ph'(in,in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A) :- constr((true)).
'main@.lr.ph'(A,B,C) :- 'main@entry'(D), 
          constr((~ ((1=<A)=E)&(F=true&(and(G,H)&(not(G)&(and(G,F)&(not(F)&(C=I&(not(F)&(not(G)&(B=J&(not(F)&(not(G)&(I=1&(not(F)&(not(G)&(J=0&(not(F)&(not(G)&(not(H)&(not(E)&(not(G)&K=D)))))))))))))))))))))).
'main@.lr.ph'(A,B,C) :- 'main@.lr.ph'(A,D,E), 
          constr((~ ((A=<E)=F)&(G=true&(and(H,G)&(not(G)&(F&(not(G)&(not(H)&(C=I&(not(G)&(not(H)&(B=J&(not(G)&(not(H)&(I=K&(not(G)&(not(H)&(J=L&(not(G)&(not(H)&(K=1+E&(L=ite(M,- 10,N)&(N=2+D&M=(E=4)))))))))))))))))))))))).
'main@orig.main.exit.split' :- 'main@entry'(A), 
          constr((~ ((1=<B)=C)&(D=true&(not(E)&(not(F)&(and(D,E)&(not(D)&(G&(not(E)&(and(E,H)&(not(E)&(I=2*B&(not(E)&(J=(K=0)&(not(E)&(not(L=G)&(not(E)&(L=or(J,M)&(not(E)&(M=(K=I)&(not(E)&(C&(not(H)&(not(E)&(N=0&(not(H)&(not(E)&(K=N&(not(H)&(not(E)&O=A)))))))))))))))))))))))))))))).
'main@orig.main.exit.split' :- 'main@.lr.ph'(A,B,C), 
          constr((~ ((A=<C)=D)&(E=true&(not(F)&(not(G)&(and(E,F)&(not(E)&(H&(not(F)&(and(F,I)&(not(F)&(J=2*A&(not(F)&(K=(L=0)&(not(F)&(not(M=H)&(not(F)&(M=or(K,N)&(not(F)&(N=(L=J)&(not(F)&(and(I,O)&(not(I)&(P=Q&(not(I)&(not(F)&(L=P&(not(I)&(not(F)&(not(D)&(not(O)&(not(I)&(R=S&(not(O)&(not(I)&(Q=R&(not(O)&(not(I)&(S=ite(T,- 10,U)&(V=1+C&(U=2+B&T=(C=4)))))))))))))))))))))))))))))))))))))))))).
ff :- 'main@orig.main.exit.split', constr((true)).

