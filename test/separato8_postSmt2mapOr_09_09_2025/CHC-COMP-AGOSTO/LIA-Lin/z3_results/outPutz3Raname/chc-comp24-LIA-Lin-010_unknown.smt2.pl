% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@isodd.exit.split'.
:- pred 'main@tailrecurse.i'(int,int).
:- mode 'main@tailrecurse.i'(in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B) :- 'main@entry', 
          constr((~ ((0=<A)=C)&(D=true&(~C&(and(E,D)&(not(D)&(B=F&(not(D)&(not(E)&(F=A&(not(D)&not(E)))))))))))).
'main@tailrecurse.i'(A,B) :- 'main@tailrecurse.i'(A,C), 
          constr((~ ((1=<C)=D)&(E=true&(F=(C=2)&(not(G)&(H= - 2+C&(not(G)&(and(G,E)&(not(E)&(I&(not(J)&(and(I,K)&(not(I)&(L=(C=1)&(not(I)&(M&(not(N)&(and(M,K)&(not(M)&(O=(C=0)&(not(M)&(not(F)&(not(E)&(not(G)&(B=P&(not(E)&(not(G)&(P=H&(not(E)&(not(G)&(and(N,M)&(and(J,I)&(not(G)&(not(I)&(not(J)&(not(L)&(not(K)&(not(D)&(not(I)&(not(M)&(not(N)&(not(O)&(not(K)&(D&not(M))))))))))))))))))))))))))))))))))))))))))))).
'main@isodd.exit.split' :- 'main@tailrecurse.i'(A,B), 
          constr((~ ((1=<B)=C)&(D=true&(not(E)&(F&(not(G)&(F&(and(F,H)&(not(F)&(I=(B=1)&(not(F)&(J&(not(K)&(not(L)&(J&(and(J,H)&(not(J)&(M=(B=0)&(not(J)&(N&(not(O)&(P=(B=2)&(not(N)&(Q= - 2+B&(not(N)&(and(D,R)&(not(D)&(not(S)&(not(R)&(S=(T=U)&(not(R)&(U=A mod 2&(not(R)&(not(E)&(I&(not(F)&(not(G)&(not(I)&(not(F)&(T=V&(not(E)&(not(F)&(V=1&(not(E)&(not(F)&(not(H)&(not(C)&(not(F)&(M&(not(J)&(not(K)&(T=W&(not(J)&(not(K)&(W=0&(not(J)&(not(K)&(not(L)&(not(M)&(not(J)&(not(H)&(C&(not(J)&(P&(not(N)&(not(O)&(T=X&(not(N)&(not(O)&(X=0&(not(N)&(not(O)&(and(J,L)&(and(F,G)&(not(N)&(and(O,N)&(and(K,J)&(and(F,E)&not(R))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))).
ff :- 'main@isodd.exit.split', constr((true)).

