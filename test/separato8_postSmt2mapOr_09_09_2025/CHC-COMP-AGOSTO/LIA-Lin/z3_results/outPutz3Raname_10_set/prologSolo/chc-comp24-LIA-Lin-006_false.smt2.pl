% Automatically generated by smt2map




:- pred 'main@entry'.
:- pred 'main@tailrecurse.i'(int,int,int,int).
:- mode 'main@tailrecurse.i'(in,in,in,in).
:- pred 'main@sum.exit.split'.
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry' :- constr((true)).
'main@tailrecurse.i'(A,B,C,D) :- 'main@entry', 
          constr((E=(B=0)&(F=true&(or(not(G),and(G,H))&(or(not(F),and(G,F))&(or(not(G),or(not(F),D=I))&(or(not(G),or(not(F),C=J))&(or(not(G),or(not(F),J=B))&(or(not(G),or(not(F),I=A))&or(not(G),or(not(E),not(H)))))))))))).
'main@tailrecurse.i'(A,B,C,D) :- 'main@tailrecurse.i'(A,B,E,F), 
          constr((G=(H=0)&(I=true&(or(not(I),and(J,I))&(or(not(J),or(not(I),not(G)))&(or(not(J),or(not(I),D=K))&(or(not(J),or(not(I),C=L))&(or(not(J),or(not(I),L=H))&(or(not(J),or(not(I),K=M))&(H= - 1+E&M=1+F)))))))))).
'main@sum.exit.split' :- 'main@entry', 
          constr((A=(B=0)&(C=true&(or(not(C),and(C,D))&(or(not(D),E)&(or(not(D),and(F,D))&(or(not(D),G=H+B)&(or(not(D),E=(I=G))&(or(not(F),or(A,not(D)))&(or(not(F),or(I=J,not(D)))&or(not(F),or(J=H,not(D))))))))))))).
'main@sum.exit.split' :- 'main@tailrecurse.i'(A,B,C,D), 
          constr((E=(F=0)&(G=true&(or(not(H),and(H,I))&(or(not(G),and(G,J))&(or(not(J),K)&(or(not(J),and(H,J))&(or(not(J),L=A+B)&(or(not(J),K=(M=L))&(or(not(H),or(M=N,not(J)))&(or(not(H),or(N=O,not(J)))&(or(not(H),or(not(I),E))&(or(not(H),or(not(I),O=P))&(or(not(H),or(not(I),P=Q))&(Q=1+D&F= - 1+C))))))))))))))).
ff :- 'main@sum.exit.split', constr((true)).

