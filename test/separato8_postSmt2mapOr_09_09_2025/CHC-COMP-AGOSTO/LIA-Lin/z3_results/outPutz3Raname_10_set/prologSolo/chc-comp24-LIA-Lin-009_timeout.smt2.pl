% Automatically generated by smt2map




:- pred 'main@entry'(int).
:- mode 'main@entry'(in).
:- pred 'main@id.exit.split'.
:- pred 'main@tailrecurse.i'(int,int).
:- mode 'main@tailrecurse.i'(in,in).
:- pred ff.
:- query ff/0.
:- pred constr(bool).
:- mode constr(in).
:- ignore constr/1.

'main@entry'(A) :- constr((true)).
'main@tailrecurse.i'(A,B) :- 'main@entry'(C), 
          constr((D=(E=0)&(F=true&(or(not(G),and(G,H))&(or(not(F),and(G,F))&(or(not(G),or(not(F),B=I))&(or(not(G),or(not(F),A=J))&(or(not(G),or(not(F),I=0))&(or(not(G),or(not(F),J=E))&(or(not(G),or(not(D),not(H)))&K=C)))))))))).
'main@tailrecurse.i'(A,B) :- 'main@tailrecurse.i'(C,D), 
          constr((E=(F=0)&(G=true&(or(not(G),and(H,G))&(or(not(H),or(not(G),not(E)))&(or(not(H),or(not(G),B=I))&(or(not(H),or(not(G),A=J))&(or(not(H),or(not(G),I=K))&(or(not(H),or(not(G),J=F))&(K=1+D&F= - 1+C)))))))))).
'main@id.exit.split' :- 'main@entry'(A), 
          constr((B=(C=0)&(D=true&(or(not(D),and(D,E))&(or(not(E),F)&(or(not(E),and(E,G))&(or(not(E),or(not(H),not(G)))&(or(not(E),or(not(G),B))&(or(not(E),or(not(G),F=H))&I=A))))))))).
'main@id.exit.split' :- 'main@tailrecurse.i'(A,B), 
          constr((C=(D=0)&(E=true&(or(not(E),and(E,F))&(or(not(F),G)&(or(not(F),and(F,H))&(or(not(H),and(H,I))&(or(not(H),J=(K=100))&(or(not(F),or(not(H),L=J))&(or(not(F),or(not(H),G=L))&(or(not(H),or(not(I),C))&(or(not(H),or(not(I),K=M))&(or(not(H),or(not(I),M=N))&(N=1+B&D= - 1+A)))))))))))))).
ff :- 'main@id.exit.split', constr((true)).

