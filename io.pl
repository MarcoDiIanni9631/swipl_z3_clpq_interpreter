:- module(io, [
    load_clean/1,
    load_clean_lines/1,
    read_full_term/2,
    read_full_term/3,
    should_skip_line/1,
    arg_type/3
]).

:- use_module(library(readutil)).
:- dynamic arg_type/3.

% ----------------------------
% Caricamento e parsing file
% ----------------------------

load_clean(File) :-
    retractall(arg_type(_,_,_)),
    open(File, read, Stream),
    load_clean_lines(Stream),
    close(Stream).

load_clean_lines(Stream) :-
    read_full_term(Stream, FullTermString),
    ( FullTermString == end_of_file ->
        true
    ; string_lower(FullTermString, Lower),
      sub_string(Lower, _, _, _, ":- pred") ->
        try_parse_pred_line(FullTermString),
        load_clean_lines(Stream)
    ; should_skip_line(FullTermString) ->
        writeln(skipping(FullTermString)),
        load_clean_lines(Stream)
    ; open_string(FullTermString, LineStream),
      catch(
          read_term(LineStream, Term, [syntax_errors(dec10)]),
          _Err,
          Term = fail
      ),
      close(LineStream),
      ( Term == fail ->
            writeln('Errore di parsing!'),
            load_clean_lines(Stream)
      ; user:assertz(Term),
        load_clean_lines(Stream)
      )
    ).

% ----------------------------
% Parsing riga multipla
% ----------------------------

read_full_term(Stream, Full) :-
    read_line_to_string(Stream, Line0),
    ( Line0 == end_of_file ->
        Full = end_of_file
    ; strip_autogen(Line0, Line),
      read_full_term(Stream, Line, Full)
    ).

read_full_term(Stream, Acc, Full) :-
    ( sub_string(Acc, _, 1, 0, ".") ->
        Full = Acc
    ; read_line_to_string(Stream, Next0),
      ( Next0 == end_of_file ->
          Full = Acc
      ; strip_autogen(Next0, Next),
        string_concat(Acc, " ", Temp),
        string_concat(Temp, Next, NewAcc),
        read_full_term(Stream, NewAcc, Full)
      )
    ).

% ----------------------------
% Parsing dichiarazioni pred
% ----------------------------

try_parse_pred_line(Line) :-
    normalize_space(string(S), Line),
    ( catch(extract_pred_type(S), Err,
            (print_message(error, Err), fail)) ->
        true
    ; format("skipped parse: ~q~n", [S])
    ).

extract_pred_type(Line) :-
    string_codes(Line, Codes),
    phrase(pred_decl(Name/Arity, Types), Codes),
    Arity > 0,
    forall(nth1(Pos, Types, T), (
        ( T = array(Inner) ->
              assertz(arg_type(Name/Arity, Pos, array(Inner, Inner)))
        ;     assertz(arg_type(Name/Arity, Pos, T))
        )
    )).

pred_decl(Name/Arity, Types) -->
    ":- pred ", whites, pred_head(Name, Types), whites, ".", !,
    { length(Types, Arity) }.

pred_head(Name, Types) -->
    atom_string(Name), "(", type_list(Types), ")".

atom_string(Atom) -->
    string_without("(", Cs),
    {
        string_codes(S, Cs),
        normalize_space(string(S1), S),
        strip_quotes(S1, S2),
        atom_string(Atom, S2)
    }.

strip_quotes(Str, Unquoted) :-
    string_length(Str, Len),
    ( Len >= 2,
      sub_string(Str, 0, 1, _, "'"),
      sub_string(Str, _, 1, 0, "'") ->
        LenMinus2 is Len - 2,
        sub_string(Str, 1, LenMinus2, 1, Unquoted)
    ; Unquoted = Str
    ).

type_list([T|Ts]) -->
    whites, type_term(T), whites,
    ( "," -> type_list(Ts) ; [] ).
type_list([]) --> [].

type_term(array(Inner)) -->
    "array(", type_term(Inner), ")", !.
type_term(T) -->
    string_without(",)", Cs),
    {
        string_codes(S, Cs),
        normalize_space(string(Str), S),
        atom_string(T, Str)
    }.

% ----------------------------
% Linee da ignorare
% ----------------------------

should_skip_line(Line) :-
    string_lower(Line, Lower),
    (
        sub_string(Lower, _, _, _, ":- mode");
        sub_string(Lower, _, _, _, ":- query");
        sub_string(Lower, _, _, _, ":- ignore")
    ).

% ----------------------------
% Pulizia riga autogenerata
% ----------------------------

strip_autogen(Line, "") :-
    string_lower(Line, Lower),
    normalize_space(string(Flat), Lower),
    Flat = "% automatically generated by smt2map",
    !.
strip_autogen(Line, Line).